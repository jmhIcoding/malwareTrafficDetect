#coding:utf8
#本模块实现了获取数据的类和接口
__author__ ='jmh081701'
import socket
import struct
import define
import numpy as np
class CaptureDataProvider(object):
    #数据提供模型,本类可供train和test一起用
    #windows下使用回环地址上的套接字获取数据,但是这种的方法的效率不高。
    #解决方法:预读取数据！每次多接受套接字,空闲的时候获取数据？
    #Windows下共享内存的方式或许会更高效！！！--->使用共享内存!(太复杂,而且要考虑同步机制，暂时不采取）
    #Linux:使用Domian Socket或共享内存
    def __init__(self,mapfile):
        pass

    def next_batch(self,batch_size):
        '''
        :param batch_size: 数据批数
        :return:
        '''
        pass
    def sample_size(self):
        '''
        :return: 样本的数目
        '''
        pass

    def next_batch_label(self,batch_size):
        '''
        :param batch_size:
        :return: 返回指定批数大小个label
        '''
        pass

    def next_batch_vector(self,batch_size):
        '''

        :param batch_size:
        :return:返回指定批数大小个输入向量
        '''
        pass
    def seperate_raw_data(self,data,batch_size,pkt_num,pkt_length):
        '''
        将原始的数据报文分割成一个个的向量
        :param data:
        :return:
        '''
        mat =np.zeros(shape=(batch_size,pkt_length*pkt_num))



class CaptureDataManager(object):
    #数据管理模块
    def __init__(self,host="127.0.0.1",port=10001):
        self.managerSock=socket.socket()
        try:
            self.managerSock.connect((host,port))
        except:
            print("%s:%d connect error."%(host,port))
            exit(-1)

    def request_data(self,batch_size,pkt_num,pkt_length):
        data=struct.pack("I",0x02)+struct.pack("I",batch_size)+struct.pack("I",pkt_num)+struct.pack("I",pkt_length)
        self.managerSock.send(data)
        return self.managerSock.recv(batch_size*pkt_length*pkt_num)
    def send_data_request(self,batch_size,pkt_num,pkt_length):
        '''
        本函数用于向目的地址提交数据申请,让对方准备好数据。
        :param batch_size:
        :param pkt_num:
        :param pkt_length:
        :return:
        '''
        data=struct.pack("I",0x00)+struct.pack("I",batch_size)+struct.pack("I",pkt_num)+struct.pack("I",pkt_length)
        self.managerSock.send(data)
        #self.managerSock.recv(bufsiz=define.BufferSize)
    def recv_data_status(self):
        '''
        本函数用于获取目的地有多少可用的数据
        :return:(batch_size,pkt_num,pkt_length)
        '''
        data=struct.pack("I",0x01)+b'\x00\x00\x00\x00'+b'\x00\x00\x00\x00'+b'\x00\x00\x00\x00'
        self.managerSock.send(data)
        recv_data=self.managerSock.recv(define.BufferSize)
        batch_size=struct.unpack_from("I",recv_data,0)
        pkt_num=struct.unpack_from("I",recv_data,4)
        pkt_length=struct.unpack_from("I",recv_data,8)
        return batch_size,pkt_num,pkt_length


if __name__ == '__main__':
    #CaptureDataManager().send_data_request(64,16,128)
    manager=CaptureDataManager()
    pkt_length=128
    pkt_num=16
    data=manager.request_data(1,pkt_num,pkt_length)
    s=""
    for i in range(1,len(data)+1):
        s+=" "+str(hex(data[i-1
        ]))
        if i % 16 ==0:
            print(s+"\n")
            s=""
        if i% (pkt_length) ==0 :
            print("next pkt \n")

    data=manager.request_data(1,pkt_num,pkt_length)
    s=""
    for i in range(1,len(data)+1):
        s+=" "+str(hex(data[i-1]))
        if i % 16 ==0:
            print(s+"\n")
            s=""
        if i% (pkt_length) ==0 :
            print("next pkt \n")