#coding:utf8
#本模块实现了获取数据的类和接口
__author__ ='jmh081701'
import socket
import struct
import define
class CaptureDataProvider(object):
    #数据提供模型,本类可供train和test一起用
    #windows下使用回环地址上的套接字获取数据,但是这种的方法的效率不高。
    #解决方法:预读取数据！每次多接受套接字,空闲的时候获取数据？
    #Windows下共享内存的方式或许会更高效！！！--->使用共享内存
    #Linux:使用Domian Socket或共享内存
    def __init__(self,mapfile):
        pass

    def next_batch(self,batch_size):
        '''
        :param batch_size: 数据批数
        :return:
        '''
        pass
    def sample_size(self):
        '''
        :return: 样本的数目
        '''
        pass

    def next_batch_label(self,batch_size):
        '''
        :param batch_size:
        :return: 返回指定批数大小个label
        '''
        pass

    def next_batch_vector(self,batch_size):
        '''

        :param batch_size:
        :return:返回指定批数大小个输入向量
        '''
        pass


class CaptureDataManager(object):
    #数据管理模块
    def __init__(self,host="127.0.0.1",port=10001):
        self.managerSock=socket.socket()
        try:
            self.managerSock.connect((host,port))
        except:
            print("%s:%d connect error."%(host,port))
            exit(-1)


    def send_data_request(self,batch_size,pkt_num,pkt_length):
        data=struct.pack("!I",0x00)+struct.pack("!I",batch_size)+struct.pack("!I",pkt_num)+struct.pack("!I",pkt_length)
        self.managerSock.send(data)
        #self.managerSock.recv(bufsiz=define.BufferSize)
    def recv_data_response(self):
        pass

if __name__ == '__main__':
    CaptureDataManager().send_data_request(64,16,128)